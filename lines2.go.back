package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"github.com/fatih/color"
)

var (
	quietMode     = flag.Bool("q", false, "Тихий режим (только итог)")
	skipEmpty     = flag.Bool("ss", false, "Пропускать пустые строки")
	recursive     = flag.Bool("r", false, "Рекурсивный поиск")
	excludeDirs   = flag.String("ex", "vendor", "Директории для исключения (через запятую)")
	githubURL     = flag.String("url", "", "GitHub URL репозитория")
)

// Структуры для парсинга GitHub API
type GitHubTree struct {
	SHA  string `json:"sha"`
	URL  string `json:"url"`
	Tree []struct {
		Path string `json:"path"`
		Type string `json:"type"`
	} `json:"tree"`
}

type GitHubFile struct {
	Path string
	Lines int
}

func countLines(filePath string) (int, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lines := 0
	for scanner.Scan() {
		line := scanner.Text()
		if *skipEmpty {
			if strings.TrimFunc(line, unicode.IsSpace) == "" {
				continue
			}
		}
		lines++
	}
	return lines, scanner.Err()
}

func countLinesFromContent(content string) int {
	lines := 0
	scanner := bufio.NewScanner(strings.NewReader(content))
	for scanner.Scan() {
		line := scanner.Text()
		if *skipEmpty {
			if strings.TrimFunc(line, unicode.IsSpace) == "" {
				continue
			}
		}
		lines++
	}
	return lines
}

func isExcluded(path string) bool {
	excluded := strings.Split(*excludeDirs, ",")
	for _, dir := range excluded {
		dir = strings.TrimSpace(dir)
		if strings.Contains(path, dir) {
			return true
		}
	}
	return false
}

func extractRepoInfo(url string) (string, string, string, error) {
	// Регулярное выражение для извлечения username/reponame из GitHub URL
	re := regexp.MustCompile(`github\.com/([^/]+)/([^/]+?)(?:\.git)?$`)
	matches := re.FindStringSubmatch(url)
	if len(matches) != 3 {
		return "", "", "", fmt.Errorf("неверный формат GitHub URL")
	}
	return matches[1], matches[2], "main", nil
}

func getGitHubFiles(username, repo, branch string) ([]GitHubFile, error) {
	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/%s/git/trees/%s?recursive=1", username, repo, branch)
	
	client := &http.Client{}
	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return nil, err
	}
	
	// Добавляем заголовки для GitHub API
	req.Header.Set("Accept", "application/vnd.github.v3+json")
	
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("ошибка API: %s", resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var tree GitHubTree
	err = json.Unmarshal(body, &tree)
	if err != nil {
		return nil, err
	}

	var files []GitHubFile
	for _, item := range tree.Tree {
		if item.Type == "blob" { // blob - это файл, tree - это директория
			files = append(files, GitHubFile{Path: item.Path})
		}
	}

	return files, nil
}

func getFileContent(username, repo, branch, filePath string) (string, error) {
	rawURL := fmt.Sprintf("https://raw.githubusercontent.com/%s/%s/%s/%s", username, repo, branch, filePath)
	
	resp, err := http.Get(rawURL)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("ошибка загрузки файла: %s", resp.Status)
	}

	content, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(content), nil
}

func processGitHubRepo(url, pattern string) {
	username, repo, branch, err := extractRepoInfo(url)
	if err != nil {
		color.Red("Ошибка: %v", err)
		return
	}

	if !*quietMode {
		color.Cyan("Анализ GitHub репозитория: %s/%s", username, repo)
		color.Cyan("Шаблон поиска: %s", pattern)
		fmt.Println(strings.Repeat("-", 50))
	}

	files, err := getGitHubFiles(username, repo, branch)
	if err != nil {
		color.Red("Ошибка получения файлов: %v", err)
		return
	}

	total := 0
	blue := color.New(color.FgBlue).SprintFunc()
	matchedFiles := 0

	for _, file := range files {
		// Проверяем исключения
		if isExcluded(file.Path) {
			continue
		}

		// Проверяем шаблон
		matched, _ := filepath.Match(pattern, filepath.Base(file.Path))
		if matched {
			content, err := getFileContent(username, repo, branch, file.Path)
			if err != nil {
				if !*quietMode {
					color.Yellow("%s: ошибка загрузки - %v", file.Path, err)
				}
				continue
			}

			lines := countLinesFromContent(content)
			file.Lines = lines

			if !*quietMode {
				fmt.Printf("%s: %d\n", blue(file.Path), lines)
			}
			total += lines
			matchedFiles++
		}
	}

	if matchedFiles == 0 {
		if !*quietMode {
			color.Red("Файлы не найдены.")
		}
		return
	}

	if *quietMode {
		fmt.Println(total)
	} else {
		color.Green("Всего строк: %d (%s)", total, pattern)
		color.Cyan("Обработано файлов: %d", matchedFiles)
	}
}

func main() {
	flag.Parse()
	args := flag.Args()

	// Если указан URL, работаем с GitHub репозиторием
	if *githubURL != "" {
		pattern := "*"
		if len(args) > 0 {
			pattern = args[0]
		}
		processGitHubRepo(*githubURL, pattern)
		return
	}

	// Старая логика для локальных файлов
	if len(args) == 0 {
		fmt.Println("Укажите шаблон (например, *.go) или используйте -url для GitHub репозитория")
		os.Exit(1)
	}

	pattern := args[0]
	var files []string

	walker := func(path string, info os.FileInfo, err error) error {
		if err != nil || isExcluded(path) {
			return nil
		}
		if !info.IsDir() {
			matched, _ := filepath.Match(pattern, filepath.Base(path))
			if matched {
				files = append(files, path)
			}
		}
		return nil
	}

	if *recursive {
		filepath.Walk(".", walker)
	} else {
		entries, _ := os.ReadDir(".")
		for _, entry := range entries {
			if !entry.IsDir() && !isExcluded(entry.Name()) {
				matched, _ := filepath.Match(pattern, entry.Name())
				if matched {
					files = append(files, entry.Name())
				}
			}
		}
	}

	if len(files) == 0 {
		if !*quietMode {
			color.Red("Файлы не найдены.")
		}
		return
	}

	total := 0
	blue := color.New(color.FgBlue).SprintFunc()
	red := color.New(color.FgRed).SprintFunc()

	for _, file := range files {
		lines, err := countLines(file)
		if err != nil {
			if !*quietMode {
				fmt.Printf("%s: %s\n", blue(file), red("ошибка"))
			}
			continue
		}
		if !*quietMode {
			fmt.Printf("%s: %d\n", blue(file), lines)
		}
		total += lines
	}

	if *quietMode {
		fmt.Println(total)
	} else {
		color.Green("Всего строк: %d (%s)", total, pattern)
	}
}
